// Code generated by protoc-gen-zig
///! package proto.hiero
const std = @import("std");

const protobuf = @import("protobuf");
const fd = protobuf.fd;
/// import package proto.gradido
const proto_gradido = @import("gradido.pb.zig");

/// *
/// A unique identifier for an Hedera account.
///
/// An account identifier is of the form `shard.realm.[number|alias]`.<br/>
/// The identifier MAY use the alias form when transferring HBAR to a public key
/// before the account for that key is created, when only the alias value is
/// known, or in some smart contracts that use the EVM address style alias to
/// refer to Accounts.<br/>
/// When the account entry is completed, the alias SHALL be stored separately in
/// the Account record, and the identifier in the Account SHALL use the
/// `accountNum` form.
///
/// ---
/// ### Additional Notes
///
/// #### Alias
/// There is considerable complexity with `alias` (aka `evm_address`) for
/// Accounts. Much of this comes from the existence of a "hidden" alias for
/// almost all accounts, and the reuse of the alias field for both EVM reference
/// and "automatic" account creation.<br/>
/// For the purposes of this specification, we will use the following terms for
/// clarity.
/// - `key_alias`<br/>
/// The account public key as a protobuf serialized message and used for
/// auto-creation and subsequent lookup. This is only valid if the account
/// key is a single `primitive` key, either Ed25519 or ECDSA_SECP256K1.
/// - `evm_address`<br/>
/// Exists for every account and is one of
/// - `contract_address`<br/>
/// The 20 byte EVM address prescribed by `CREATE` or `CREATE2`
/// - `evm_key_address`<br/>
/// An arbitrary 20 byte EVM address that, for a usable externally owned
/// account (EOA) SHALL be the rightmost 20 bytes of the Keccak-256 hash
/// of a ECDSA_SECP256K1 key.<br/>
/// Such accounts may be created in one of three ways:
/// - Sending hbar or fungible tokens to an unused
/// ECDSA_SECP256K1 key alias.
/// - Sending hbar or fungible tokens to an unassigned 20-byte
/// EVM address.
/// - Submitting a `CryptoCreate` signed with the corresponding
/// private key.
/// - `long_zero`<br/>
/// A synthetic 20 byte address inferred for "normally" created accounts.
/// It is constructed from the "standard" AccountID as follows.
/// 1. 4 byte big-endian shard number
/// 1. 8 byte big-endian realm number
/// 1. 8 byte big-endian entity number<br/>
///
/// The `alias` field in the `Account` message SHALL contain one of four values
/// for any given account.
/// - The `key_alias`, if the account was created by transferring HBAR to the
/// `key_alias` public key value.
/// - The `evm_key_address` if the account was created from an EVM public key
/// - The `contract_address` if the account belongs to an EVM contract
/// - Not-Set/null/Bytes.EMPTY (collectively `null`) if the account was
/// created normally
///
/// If the `alias` field of an `Account` is any form of `null`, then the account
/// MAY be referred to by `alias` in an `AccountID` by using the `long_zero`
/// address for the account.<br/>
/// This "hidden default" alias SHALL NOT be stored, but is synthesized by the
/// node software as needed, and may be synthesized by an EVM contract or client
/// software as well.
///
/// ---
///
/// #### Alias forms
/// An `AccountID` in a transaction MAY reference an `Account` with
/// `shard.realm.alias`.<br/>
/// If the account `alias` field is set for an Account, that value SHALL be the
/// account alias.<br/>
/// If the account `alias` field is not set for an Account, the `long_zero` alias
/// SHALL be the account alias.
pub const AccountID = struct {
    shardNum: i64 = 0,
    realmNum: i64 = 0,
    account: ?account_union = null,

    pub const _account_case = enum {
        accountNum,
        alias,
    };
    pub const account_union = union(_account_case) {
        accountNum: i64,
        alias: []const u8,
        pub const _desc_table = .{
            .accountNum = fd(3, .{ .scalar = .int64 }),
            .alias = fd(4, .{ .scalar = .bytes }),
        };
    };

    pub const _desc_table = .{
        .shardNum = fd(1, .{ .scalar = .int64 }),
        .realmNum = fd(2, .{ .scalar = .int64 }),
        .account = fd(null, .{ .oneof = account_union }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// *
/// An unique identifier for a topic.<br/>
/// Topics are part of the consensus service, messages are published to a topic.
pub const TopicID = struct {
    shardNum: i64 = 0,
    realmNum: i64 = 0,
    topicNum: i64 = 0,

    pub const _desc_table = .{
        .shardNum = fd(1, .{ .scalar = .int64 }),
        .realmNum = fd(2, .{ .scalar = .int64 }),
        .topicNum = fd(3, .{ .scalar = .int64 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};

/// *
/// A transaction identifier.<br/>
/// This is used for retrieving receipts and records for a transaction
/// and internally by the network for detecting when duplicate transactions are
/// submitted.
///
/// A transaction may be processed more reliably by submitting it to
/// several nodes, each with a different node account, but all with the same
/// TransactionID. Then, the transaction will take effect when the first of all
/// those nodes submits the transaction and it reaches consensus. The other
/// transactions SHALL NOT be executed (and SHALL result in a
/// `DUPLICATE_TRANSACTION` response).<br/>
/// Multiple submission increase reliability on the assumption that an error in,
/// for example, network connectivity will not affect all nodes equally. Latency
/// might be slightly lower, if one node is handling intake significantly slower
/// than others, for example. The base transaction fee is required for each
/// submission, however, so the total fees charged are significantly higher when
/// using this approach.
///
/// ### Requirements
/// Each transaction identifier MUST be unique.<br/>
/// Multiple transactions MAY be submitted with the same transaction
/// identifier, but all except the first SHALL be rejected as duplicate
/// transactions.<br/>
/// An identifier MUST specify a `payer` account to be charged all fees
/// associated with the transaction.<br/>
/// The `payer` account MUST exist and MUST have sufficient HBAR to pay all
/// transaction fees.<br/>
/// An identifier MUST specify a "valid start time".<br/>
/// The "valid start time" MUST be strictly _earlier_ than the current
/// network consensus time when submitted.<br/>
/// The "valid start time" MUST NOT be more than `transaction.maxValidDuration`
/// seconds before the current network consensus time when submitted.<br/>
/// A client-submitted transaction MUST NOT set the `scheduled` flag.
///
/// ### Additional Notes
///
/// Additional items applicable to Scheduled Transactions:
///
/// - The ID of a Scheduled Transaction, once executed, SHALL inherit both
/// `transactionValidStart` and `accountID` from the `ScheduleCreate`
/// transaction that created the schedule.
/// - The `scheduled` property SHALL be set for Scheduled Transactions.
pub const TransactionID = struct {
    transactionValidStart: ?proto_gradido.Timestamp = null,
    accountID: ?AccountID = null,
    scheduled: bool = false,
    nonce: i32 = 0,

    pub const _desc_table = .{
        .transactionValidStart = fd(1, .submessage),
        .accountID = fd(2, .submessage),
        .scheduled = fd(3, .{ .scalar = .bool }),
        .nonce = fd(4, .{ .scalar = .int32 }),
    };

    /// Encodes the message to the writer
    /// The allocator is used to generate submessages internally.
    /// Hence, an ArenaAllocator is a preferred choice if allocations are a bottleneck.
    pub fn encode(
        self: @This(),
        writer: *std.Io.Writer,
        allocator: std.mem.Allocator,
    ) (std.Io.Writer.Error || std.mem.Allocator.Error)!void {
        return protobuf.encode(writer, allocator, self);
    }

    /// Decodes the message from the bytes read from the reader.
    pub fn decode(
        reader: *std.Io.Reader,
        allocator: std.mem.Allocator,
    ) (protobuf.DecodingError || std.Io.Reader.Error || std.mem.Allocator.Error)!@This() {
        return protobuf.decode(@This(), reader, allocator);
    }

    /// Deinitializes and frees the memory associated with the message.
    pub fn deinit(self: *@This(), allocator: std.mem.Allocator) void {
        return protobuf.deinit(allocator, self);
    }

    /// Duplicates the message.
    pub fn dupe(self: @This(), allocator: std.mem.Allocator) std.mem.Allocator.Error!@This() {
        return protobuf.dupe(@This(), self, allocator);
    }

    /// Decodes the message from the JSON string.
    pub fn jsonDecode(
        input: []const u8,
        options: std.json.ParseOptions,
        allocator: std.mem.Allocator,
    ) !std.json.Parsed(@This()) {
        return protobuf.json.decode(@This(), input, options, allocator);
    }

    /// Encodes the message to a JSON string.
    pub fn jsonEncode(
        self: @This(),
        options: std.json.Stringify.Options,
        allocator: std.mem.Allocator,
    ) ![]const u8 {
        return protobuf.json.encode(self, options, allocator);
    }

    /// This method is used by std.json
    /// internally for deserialization. DO NOT RENAME!
    pub fn jsonParse(
        allocator: std.mem.Allocator,
        source: anytype,
        options: std.json.ParseOptions,
    ) !@This() {
        return protobuf.json.parse(@This(), allocator, source, options);
    }

    /// This method is used by std.json
    /// internally for serialization. DO NOT RENAME!
    pub fn jsonStringify(self: *const @This(), jws: anytype) !void {
        return protobuf.json.stringify(@This(), self, jws);
    }
};
